CLAUDE DIRECTIVES - Media Organizer Pipeline
============================================================================
CRITICAL: Read the directives file before every step to refresh memory and ensure exact compliance
CRITICAL: After reading directives, print "ðŸŸ¡ READ DIRECTIVES" in yellow to confirm compliance
CRITICAL: No TIMEOUTs anywhere not in run not in copying nowhere
This file contains exact user instructions for the step-by-step debugging process
Read this file completely before any action
Use user's exact words - never reinterpret directives
============================================================================

=== SECTION 1: GENERAL ALGORITHM ===
============================================================================
High-level step-by-step process flow
============================================================================

Normal Flow:
run X.0: Enable current step
run X.1: Check standards
run X.2: Run Python pipeline
run X.3: Run PowerShell pipeline
run X.4: Compare outputs
run X.5: Check match
run X.6: Delete old backup
run X.7: Create new backup
run x.8: reRead the directives
run X.9: Increment X and loop


Standards Flow (when run X.5 fails):
standards X.0: Fix standards violations
standards X.1: Reread the directives
standards X.2: Continue with normal flow

Debug Flow (when run X.1 fails):
debug X.0: Debug failure
debug X.1: Fix code
debug X.2: Remove bogus outputs
debug X.3: Restore from backup
debug X.4: Test fix
debug X.5: Compare again
debug X.6: Document lessons
debug X.7: reread the directives
debug X.8: Evaluate (passâ†’run X.2, failâ†’debug X.0)

=== SECTION 2: ABSTRACT STEP DESCRIPTIONS ===
============================================================================
High-level purpose and flow of each step
============================================================================

NORMAL EXECUTION STEPS:

run X.0: Enable current step
- In both config files, disable all steps except the current one (index `X`).

run X.1: Check standards
- Verify code for the current step `X` follows established standards before execution.

run X.2: Run Python pipeline
- Execute Python pipeline for the enabled step `X`.

run X.3: Run PowerShell pipeline
- Execute PowerShell pipeline for the enabled step `X`.

run X.4: Compare outputs
- Compare processed files, logs, and results between PowerShell and Python pipelines
- Verify file counts, sizes, and content match
- specifically the json content should match exactly, conceptually!!! maybe they are out of order

run X.5: Check match
- Evaluate comparison results from `run X.4`.
- If any difference detected
  - Create comprehensive comparison report showing:
    * File counts and total sizes for processed/logs/results
    * File-by-file comparison with exact differences
    * For mismatched files: name, size difference, content analysis
    * Speculation on root cause of differences
    * All tests completed in single report
  - do not speculate ask the user before moving forward & provide report
- If match: continue to `run X.6`.
- If mismatch: jump to debug X.0

run X.6: Delete old backup
- Remove previous step's backup if it exists (e.g., `backup_step[previous_step_index]`)

run X.7: Create new backup
- Create backup of current step's outputs (e.g., `backup_step[current_step_index]`)

run X.8: Increment X and loop
- Increment the step counter `X` and begin the loop for the next step.

STANDARDS SEQUENCE STEPS:

standards X.0: Fix standards violations
- Address any standards violations found during run X.5

standards X.1: Continue with normal flow
- Proceed with pipeline execution after fixing standards

DEBUG SEQUENCE STEPS:

debug X.0: Debug why the comparison failed
- Analyze run X.0 results to identify specific mismatches
- Check for missing files, size differences, or structural issues
- Identify which pipeline failed or if both failed

debug X.1: Fix the code
- Address identified issues in the failing pipeline(s)
- Common fixes: parameter passing, config handling, logger setup
- Ensure scripts accept proper parameters (PowerShell: -Config, Python: --config-json)

debug X.2: Remove bogus outputs
- Remove only the failing pipeline's outputs (usually just one)
- If Python failed: Remove Processed_py, Logs_py, Results_py
- If PowerShell failed: Remove Processed_ps, Logs_ps, Results_ps
- If both failed: Remove all outputs
- Clean slate for testing fixes

debug X.3: Restore from backup
- Copy from the previous step's backup (e.g., `backup_step[previous_step_index]`) to restore the failing pipeline only.
- If Python failed: Copy backup_stepX-1/processed to Processed_py, backup logs/results to Python dirs
- If PowerShell failed: Copy backup_stepX-1/processed to Processed_ps, backup logs/results to PowerShell dirs
- If both failed: Copy backup to both Processed_ps and Processed_py
- Restore clean starting state for retesting step X

debug X.4: Test fix
- Rerun only the pipeline that was failing (usually just one)
- If Python was failing: run main.py command only
- If PowerShell was failing: run main.ps1 command only
- If both were failing: run both pipelines

debug X.5: Compare again
- Use same comparison process as run X.1
- Check file counts, sizes, and any step-specific criteria
- Python threading errors are fine - ignore them

debug X.6: Document lessons learned
- Add new learnings to DIRECTIVES.txt
- Update rules, standards, or step descriptions as needed

debug X.7: Evaluate results
- If comparison passes: go to `run X.6` (delete old backup and continue)
- If comparison fails: loop back to debug X.1 (repeat debug process)

=== SECTION 3: COMMANDS ===
============================================================================
Exact commands to execute for each step
============================================================================

NORMAL EXECUTION COMMANDS:

run X.0: Enable current step
[In both config files, disable all steps, then enable the step at index `X`]

run X.4: Compare outputs
$ps_processed_count = (Get-ChildItem 'C:\Users\sawye\Downloads\test\Processed_ps' -Recurse -File | Measure-Object).Count
$py_processed_count = (Get-ChildItem 'C:\Users\sawye\Downloads\test\Processed_py' -Recurse -File | Measure-Object).Count
$ps_processed_size = (Get-ChildItem 'C:\Users\sawye\Downloads\test\Processed_ps' -Recurse -File | Measure-Object -Property Length -Sum).Sum
$py_processed_size = (Get-ChildItem 'C:\Users\sawye\Downloads\test\Processed_py' -Recurse -File | Measure-Object -Property Length -Sum).Sum
$ps_logs_count = (Get-ChildItem 'C:\Users\sawye\Codes\media_organizer\Logs_ps' -Recurse -File | Measure-Object).Count
$py_logs_count = (Get-ChildItem 'C:\Users\sawye\Codes\media_organizer\Logs_py' -Recurse -File | Measure-Object).Count
$ps_results_count = (Get-ChildItem 'C:\Users\sawye\Codes\media_organizer\Results_ps' -Recurse -File | Measure-Object).Count
$py_results_count = (Get-ChildItem 'C:\Users\sawye\Codes\media_organizer\Results_py' -Recurse -File | Measure-Object).Count
Write-Host "Processed_ps files: $ps_processed_count, size: $ps_processed_size"
Write-Host "Processed_py files: $py_processed_count, size: $py_processed_size"
Write-Host "Logs_ps files: $ps_logs_count"
Write-Host "Logs_py files: $py_logs_count"
Write-Host "Results_ps files: $ps_results_count"
Write-Host "Results_py files: $py_results_count"
$user_checks_pass = [Ask user for any other specific checks needed - return $true if all pass, $false if any fail]

run X.5: Check match
if ($ps_processed_count -ne $py_processed_count -or $ps_processed_size -ne $py_processed_size -or $ps_logs_count -ne $py_logs_count -or $ps_results_count -ne $py_results_count -or $user_checks_pass -eq $false) { Write-Host "MISMATCH - go to debug X.0" } else { Write-Host "MATCH - continue to run X.6" }

run X.6: Delete old backup
powershell -c "Remove-Item 'C:\Users\sawye\Downloads\test\backup_step[previous_step_index]' -Recurse -Force -ErrorAction SilentlyContinue"

run X.7: Create new backup
powershell -c "New-Item 'C:\Users\sawye\Downloads\test\backup_step[current_step_index]' -ItemType Directory -Force"
powershell -c "Copy-Item 'C:\Users\sawye\Downloads\test\Processed_ps' 'C:\Users\sawye\Downloads\test\backup_step[current_step_index]\processed' -Recurse -Force"
powershell -c "Copy-Item 'C:\Users\sawye\Codes\media_organizer\Logs_py' 'C:\Users\sawye\Downloads\test\backup_step[current_step_index]\python\log' -Recurse -Force"
powershell -c "Copy-Item 'C:\Users\sawye\Codes\media_organizer\Results_py' 'C:\Users\sawye\Downloads\test\backup_step[current_step_index]\python\results' -Recurse -Force"
powershell -c "Copy-Item 'C:\Users\sawye\Codes\media_organizer\Logs_ps' 'C:\Users\sawye\Downloads\test\backup_step[current_step_index]\ps1\log' -Recurse -Force"
powershell -c "Copy-Item 'C:\Users\sawye\Codes\media_organizer\Results_ps' 'C:\Users\sawye\Downloads\test\backup_step[current_step_index]\ps1\results' -Recurse -Force"

run X.1: Check standards
[Verify code for step `X` follows established standards]

run X.2: Run Python pipeline
cd "C:\Users\sawye\Codes\media_organizer" && python main.py --config "Utils/config_python.json"

run X.3: Run PowerShell pipeline
cd "C:\Users\sawye\Codes\media_organizer" && powershell -ExecutionPolicy Bypass -Command "& .\main.ps1 -Config 'Utils\config_ps.json'"

=== SECTION 4: RULES ===
============================================================================
Fundamental rules that must be followed at all times
============================================================================
- Show what you're going to do and get agreement before proceeding
- Track completed steps - never go back to good steps
- Do not speculate - follow instructions exactly
- The `Step Number` for naming and logging is the 0-based index of the step in the `pipelineSteps` array in the configuration files.
- Failed means failed - nothing moves forward until fail is resolved
- Add new information to directive file for future reference
- Use user's exact words - never reinterpret directives
- Always ask before executing commands

=== SECTION 5: STANDARDS ===
============================================================================
Technical standards that must be followed
============================================================================

=== WHAT STANDARDIZATION CHECKING ENTAILS ===
Our standard checking process (run X.1) ensures code quality and consistency:
ALL 7 categories below must be checked and pass before moving to run X.2

1. CONFIGURATION STANDARDS - Ensure proper parameter handling
   âœ… No rereading config files - use compiled config from main
   âœ… No hardcoded paths - everything from config
   âœ… Extract all paths and settings from passed config object

2. LOGGING STANDARDS - Consistent logging across all scripts  
   âœ… Use get_script_logger_with_config(config_data, script_name, step) correctly
   âœ… No invalid parameters (like console_only=True)
   âœ… Consistent MediaOrganizerLogger system across all scripts based on utilities
   âœ… Log directory from config, not hardcoded
   âœ… Proper exception handling without undefined logger variables
   âœ… Initialize-ScriptLogger requires -Config parameter for proper setup

3. CODE STRUCTURE STANDARDS - Maintain clean architecture
   âœ… Each step is separate - output goes to designated directories
   âœ… Everything uses compiled code from main
   âœ… No passing individual paths
   âœ… Steps in folder name correspond to element numbers in pipelineSteps array
   âœ… All imports use compiled code from main (Utils module)
   âœ… Proper project root path handling
   âœ… No chance for codes to run separately unless called by main

4. ERROR HANDLING STANDARDS - Safe file operations
   âœ… Proper error handling around file operations with logging
   âœ… Wrap unlink() calls in try/except blocks to catch and log deletion failures
   âœ… For PowerShell: Use -like "*.json" checks before removing files to prevent accidental media file deletion
   âœ… All file operations wrapped in try/catch with logging
   âœ… Graceful failure handling with proper exit codes

5. PIPELINE STANDARDS - Proper integration
   âœ… Enable only one step at a time in both config files
   âœ… PowerShell syntax: Proper newlines between statements - missing newlines can cause parser errors

6. INTEGRATION STANDARDS - Seamless operation
   âœ… Scripts integrate properly with main orchestrator and progress tracking
   âœ… Proper parameter passing mechanisms (PowerShell: -Config, Python: --config-json)
   âœ… No robocopy usage (user decision)
   âœ… Proper encoding handling (UTF-8 for logs and files)
   âœ… Environment variable usage follows conventions

7. RECOVERY & UNDO STANDARDS - Data protection and rollback capability
   âœ… All file deletion operations must move to deleted directory with extension checks before removal
   âœ… Create manifest files tracking all file movements with timestamps and checksums
   âœ… Log every destructive action for undo capability
   âœ… Implement rollback functions to restore from deleted directory
   âœ… Use external staging for all destructive operations
   âœ… Preserve original data until pipeline completion and user agreement
   âœ… Crash protection with save and continuation possibility
   âœ… Logging should happen for every action in a separate file for undo




=== SECTION 6: STATUS ===
============================================================================
Track what has been completed and current position
============================================================================


=== SECTION 7: CLEAN TO STEP X COMMAND ===
============================================================================
When user asks "clean to end of step X":
- Clean the environment completely
- Enable element 1 through and including element X 
- Run Python pipeline
- Run PS1 pipeline
- Set counter to step X.1
============================================================================

=== SECTION 8: SESSION HISTORY LOG ===
============================================================================

============================================================================
