📘 `SanitizeNames.Use-ValidFilesRecursively` Function Documentation

Function:
Use-ValidFilesRecursively

Description:
Recursively scans a directory tree and yields only files that pass validation checks for naming and existence.

Input Type:
1. rootPath [string] — The root directory from which to begin recursive scanning

Output Type:
✅ [string[]] — An array of valid file paths
❌ Returns empty array if no valid files are found

Algorithm (Pseudo-code):
1. Validate Input
   1.1 If rootPath is null or empty → return empty array
   1.2 If rootPath does not exist → return empty array

2. Traverse Directory
   2.1 For each file under rootPath, including subdirectories:
       2.1.1 Get file name from path
       2.1.2 Call Use-ValidFileName(name) to check validity
             🔹 Purpose: Checks for illegal characters, empty names, etc.
       2.1.3 If valid → include in result list

3. Return list of all valid file paths

Function Calls:
🔹 SanitizeNames.Use-ValidFileName(name) — Validate the base name of each file

Possible Issues:
✅ Covered: Non-existent root directory
✅ Covered: Invalid or null input
✅ Covered: Files with invalid names are filtered out
❌ Not Covered: File read permission errors (access denied)
❌ Not Covered: Symbolic link cycles
❌ Not Covered: Race conditions from concurrent file changes during traversal